# P124 Word Clock

Plugin number: P124 <br>
Plugin status: DEVELOPMENT <br>
Plugin Type: <br>
Github link:<br>

## Introduction
This is a plugin to run a word clock made of led stripes.
Based on [P041_NeoClock](https://github.com/letscontrolit/ESPEasy/blob/mega/src/_P041_NeoClock.ino).

## Todo
as this is still in development, there are something to do
* move ldr avg to plugin
* sleep mode
* push button support
* put Config of kind of stripes to config
* matrix config
* reduce libs
  * copy parts used to this plugin
  * reuse already used stuff
* run wihtout wifi: eg wifiMan P081 or P166 gets stable https://github.com/letscontrolit/ESPEasy/pull/1862/files 
  * rules: 
    * https://www.letscontrolit.com/forum/viewtopic.php?f=6&t=2846#p21370 , 
    * https://www.letscontrolit.com/forum/viewtopic.php?t=6610
  * where to get time from, no wifi no ntp no time
  * support for dct?
  * button to switch back on  

## Hardware
* LED Stripes 
  * like WS2812B/WS2813 with GRB 
  * with up to 115 LED
  * 10x11 + four minutes+ 1 Alarm
* Photo resistor
* Wemos D1

### Wiring
We have to adapt level from ESP 3.3V to 5V.
There are different options for example:
* level shifter
* sacrifice first led
* PNP

```
ESP                             LED
5V----------5V -----------------VIN-----+
            |                           [C1]
            [R2]                        |
            +---------- [R3]-+--DIN     |          
            |                '--BIN     |
D7-[R1]----[PNP]                        |
            |                           |
            |                           |
---GND -----+-------------------GND-----+

```
R1 = 3k3
R2 = 1k8
R3 = 470 Ohm, just protect input
C1 = 1000uF, 16V


Photo resistor as analog input 
    use voltage divider / resistor  
```
ESP             LDR
5V -----------[LDR]
                |
A0 -------------+
                |
               [R1]
                |
GND ------------'    
```
R1 = 10k Ohm


## ESP Easy

### Features
* uses ESPEasy own time event based on NTP to set the time
* can use LDR input values to automatically adapt brightness, see rules sections
* adjustment LED brightness for different LDR ranges via configuration
* words, minutes, alarm of the clock can be configured
* JSON status and returns
* status LED support
* alarm LED support -> can be triggered from outside eg. Domoticz
* can show short text messages
  
### Commands

each command must run with (ip)//control?cmd=
| url | type | descr |
| --- | --- | --- |
| <i>brightness</i>
| BLZWC_CLOCK  | NB | toggle clock LED on / off
| BLZWC_CLOCK,(1\|0)  | NB | turn on\|off all clock led 
| BLZWC_SETLDR,[ldr value] | B* | set ldr value and controls so brightness |
| <i>alarm</i>
| BLZWC_ALARMBREATH | NB | toggle breathing alarm
| BLZWC_ALARMBREATH,(1\|0)  | NB | turn on\|off breathing alarm
| BLZWC_ALARM | NB | toggle alarm
| BLZWC_ALARM,(1\|0)  | NB | turn on\|off alarm
| <i>testing / dev </i> |
| BLZWC_STATUS | NB | print status as Json
| BLZWC_SETTIME,(HH),(MM) | B* | fakes 'clock in', to verify LED and times
| BLZWC_TEST_ALL(,r,g,b) | B* | turns on all Leds from 0 to max, optional color, <b>r</b>ed, <b>g</b>reen, <b>b</b>lue
| BLZWC_TEST(,pos,r,g,b) | B* | turns on single led optional <b>pos</b>ition, <b>r</b>ed, <b>g</b>reen, <b>b</b>lue
| <i>fun</i> |
| BLZWC_KITT,(1\|0) | NB | KnightRiders K.I.T.T. or a snake walks through
| BLZWC_TEXT,(text) | NB | prints text on matrix


B  - blocking <br>
B* - Blocking but fast enough....<br>
NB - None Blocking <br>
NB* - partly blocking <br>

### Rules
To adapt automatically the brightness it is possible to pass current "brightness" value to the clock. 
This is done by rules at the moment.


#### passing a ldr value directly
Just use the value straight form LDR. Quite easy. But quick adjustments of LED brightness might be annoying.<br>
assumes
* device 1: word clock
* device 2: analog input a photo resistor named 'ldr'
```
On ldr#analog Do
  Taskvalueset,1,4,%eventvalue% //promote the value to the clock
  
EndOn
```

#### dummy device for average LDR values
Using a dummy device to calculate an average and just pass this avg value to clock. So the LDR can read input each second. And as we just use the avg there is no annoying switching in LED brightness.<br>
<b>Sample of 30 might be to slow</b>
<br>
assumes
* device 1: word clock
* device 2: analog input a photo resistor named 'ldr'
* device 3: dummy device with 3 fields
  * and could work with VAR#1,VAR#2,VAR#3

```
On System#Boot do
  // init and reset all on reboot
  Taskvalueset,3,3,0
  Taskvalueset,3,2,0
  Taskvalueset,3,1,0
EndOn

On System#Wake
  // init and reset all on reboot
  Taskvalueset,3,3,0
  Taskvalueset,3,2,0
  Taskvalueset,3,1,0
Endon

On ldr#analog Do
  Taskvalueset,3,3,%eventvalue%   //store newest sample to own field
  if [avgldr#publishedAverage]=0  //if it is 0 might be init, so just copy new sample value
    Taskvalueset,3,2,%eventvalue% 
  else
    //take 1/30th of the new value plus 29/30th of the published hour value
    Taskvalueset,3,2,((%eventvalue%*0.033)+([avgldr#publishedAverage]*0.966)) 
    //Taskvalueset,3,2,([avgldr#publishedAverage]*0.833)
  endif
  Taskvalueset,3,1,[avgldr#calculatedAverage] //promote the calculated Avarage to the published Average
  Taskvalueset,1,4,[avgldr#calculatedAverage] //promote the calculated Avarage to the clock
  
EndOn
```

# Change Log


